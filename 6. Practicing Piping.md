# Standard channel of communiations

1. Standard _Input_ is the channel through which the process takes input. For example, your shell uses Standard Input to read the commands that you input

2. Standard _Output_ is the channel through which processes output normal data, such as the flag when it is printed to you in previous challenges or the output of utilities such as `ls`

3.  Standard _Error_ is the channel through which processes output error details. For example, if you mistype a command, the shell will output, over standard error, that this command does not exist.

# Redirecting Output:-

We can redirect the standard output we get to a file using the `>` character 

Example:- 
```bash
echo hi > asdf
cat asdf
```

Output:- `hi`

# Appending output

`>>` is the operator used when we want to save all of the output and append it to an existing file. 

`>` creates a new file every time it is run hence cannot save output history

# File descriptors:-

- FD 0: Standard Input
- FD 1: Standard Output
- FD 2: Standard Error

These descriptors are used before the `>` character to produce the output we want to a particular file. The default is 1

Example
```bash
some_command > output.log 2> errors.log
```

Output:- The stdout will go to out.log but the stderr will go to the error.log

# Input redirection
  
Just like you can redirect _output_ from programs, you can redirect input _to_ programs! This is done using `<`, as so

# Pipe Operator

We don't need to store the output in a file in order to grep we can instead use the `|` operator to directly grep the output

Example:-
```bash
echo hello world | grep hello
```

Output:-
`*hello* world`

# Greppipng errors

The shell has a `>&` operator, which redirects a file descriptor _to another file descriptor_. This means that we can have a two-step process to `grep` through errors: first, we redirect standard error to standard output (`2>& 1`) and then pipe the now-combined stderr and stdout as normal (`|`)!

Example:-
```bash
ls nonexistentfile 2>& 1 | grep "No"
```

Ouput `ls: cannot access 'practicing': *No*such file or directory

## grep -v

The `grep` command has a very useful option: `-v` (invert match). While normal `grep` shows lines that MATCH a pattern, `grep -v` shows lines that do NOT match a pattern:

# Tee command to duplicate outputs

it is used to create copies of the output in multiple different files. In order to check why something worked or didn't work

Example
```bash
echo hi | tee pwn college
```

Output:-
The given command writes hi to two files pwn then college

# Process substitution:-

For reading from a command (input process substitution), use `<(command)`. When you write `<(command)`, bash will run the command and hook up its output to a temporary file that it will create. This isn't a _real_ file, of course, it's what's called a _named pipe_, in that it has a file name:

Example
```bash
echo <(echo hi)
```

Output:- `/dev/fd/63`

Example
```bash
cat <(echo hi)
```

Output:- hi

## Writing to command using process substiution

```bash
echo hack | tee >(rev)
```

Output:-
```
hack
kcah
```

The above program first prints out hack then send the output to tee which writes it to a temporary file that is created by >(rev). This then feeds the output into the rev command which prints out the reversed hack

# FIFO (first in first out)

A fifo is a special type of file called a pipe. Unlike regular pipes created by process substitution these stay in the system 

```bash
mkfifo my_pipe
```

this creates a file named my_pipe that behaves as a pipe.

FIFOs allow **inter-process communication**. One process writes to the FIFO, and another reads from it. But here's the catch:

- **Blocking behavior**: If one side (reader or writer) isn't ready, the other side **waits**.
- Example: `echo pwn > myfifo` will **hang** until something reads from `myfifo`      
- Once you run `cat myfifo` in another terminal, the data flows, and both commands complete.    

This blocking is actually a **feature**, not a bug—it ensures synchronization between processes.


## Fifo vs files

1. **No disk storage:** FIFOs pass data directly between processes in memory - nothing is saved to disk
2. **Ephemeral data:** Once data is read from a FIFO, it's gone (unlike files where data persists)
3. **Automatic synchronization:** Writers block until the readers are ready, and vice-versa. This is actually useful! It provides automatic synchronization. Consider the example above: with a FIFO, it doesn't matter if `cat myfifo` or `echo pwn > myfifo` is executed first; each would just wait for the other. With files, you need to make sure to execute the writer before the reader.
4. **Complex data flows:** FIFOs are useful for facilitating complex data flows, merging and splitting data in flexible ways, and so on. For example, FIFOs support multiple readers and writers.

## 1. Challenge

In this challenge, you must use this output redirection to write the word `PWN` (all uppercase) to the filename `COLLEGE` (all uppercase).

```bash
echo PWN > COLLEGE
```

Output flag:-pwn.college{M9ouQLcVfNB_-Y5IDr9YrsvXElY.QX0YTN0wCM2YTMzEzW}

## 2. Challenge
`/challenge/run` will once more give you a flag, but _only_ if you redirect its output to the file `myflag`. Your flag will, of course, end up in the `myflag` file!

```bash
/challenge/run > myflag
cat myflag
```

Output flag:-pwn.college{YxOtg16knQrDNvLF1IEv4U9bcy7.QX1YTN0wCM2YTMzEzW}

## 3. Challenge

To practice, run `/challenge/run` with an append-mode redirect of the output to the file `/home/hacker/the-flag`. The practice will write the first half of the flag to the file, and the second half to `stdout` if `stdout` is redirected to the file. 

```bash
/challenge/run >> the-flag
cat the-flag
```

Output flag:-pwn.college{ICtoXVoNxh-jOndV4BnYfRMWEPf.QX3ATO0wCM2YTMzEzW}

## 4. Challenge

redirect the output of `/challenge/run`, like before, to `myflag`, and the "errors" (in our case, the instructions) to `instructions`. You'll notice that nothing will be printed to the terminal, because you have redirected everything! You can find the instructions/feedback in `instructions` and the flag in `myflag` when you successfully pull this off!

```bash
/challenge/run > myflag 2> instructions
cat myflag
```

Output flag:- pwn.college{89PLVXs-pMzvxjB93G9ZkvLQbFl.QX3YTN0wCM2YTMzEzW}

## 5. Challenge:-

In this level, we will practice using `/challenge/run`, which will require you to redirect the `PWN` file to it and have the `PWN` file contain the value `COLLEGE`!

```bash
echo COLLEGE > PWN
/challenge/run < PWN
```

Output flag:-pwn.college{sUBZmZ6zZkBNXECZgMCNL9PCt1z.QXwcTN0wCM2YTMzEzW}

## 6. Challenge

1. Redirect the output of `/challenge/run` to `/tmp/data.txt`.
2. This will result in a hundred thousand lines of text, with one of them being the flag, in `/tmp/data.txt`.
3. `grep` that for the flag!

```bash
/challenge/run > /tmp/data.txt
grep "pwn.college" /tmp/data.txt 
```

Output flag:-pwn.college{0lAFxD7hzTS59jeqIvwIF6btFnb.QX4EDO0wCM2YTMzEzW}

## 7. Challenge

! `/challenge/run` will output a hundred thousand lines of text, including the flag. `grep` for the flag!

```bash
/challenge/run | grep "pwn.college"
```

Output flag:-pwn.college{ITM5xntlZSFJHORfUGHsZghqoZi.QX5EDO0wCM2YTMzEzW}`

## 8. Challenge

Try it now! Like the last level, this level will overwhelm you with output, but this time on standard error. `grep` through it to find the flag!

```bash
/challenge/run 2>& 1 | grep "pwn.college"
```

Output flag:-pwn.college{0F4rLyV74bHWp77SnwuT-IZAHn0.QX1ATO0wCM2YTMzEzW}

## 9. Challenge

`/challenge/run` will output the flag to stdout, but it will also output over 1000 decoy flags (containing the word `DECOY` somewhere in the flag) mixed in with the real flag. You'll need to filter _out_ the decoys while keeping the real flag!
Use `grep -v` to filter out all the lines containing "DECOY" and reveal the real flag!

```bash
/challenge/run | grep -v "DECOY"
```

Output flag:-pwn.college{MnH9CiBf2oBa-K3bOfXutbRxbOF.0FOxEzNxwCM2YTMzEzW}

## 10. Challenge

 This process' `/challenge/pwn` must be piped into `/challenge/college`, but you'll need to intercept the data to see what `pwn` needs from you!

```bash
/challenge/pwn | tee halp | /challenge/challenge
```

Output of first command

```
The input to 'college' does not contain the correct secret code! This code 
should be provided by the 'pwn' command. HINT: use 'tee' to intercept the 
output of 'pwn' and figure out what the code needs to be.
```


```bash
cat halp
```

Output of second

```
Usage: /challenge/pwn --secret [SECRET_ARG]

SECRET_ARG should be "0v22K-w6"
```

```bash
/challenge/pwn --secret 0v22K-w6 | /challenge/college
```

Output flag:- pwn.college{0v22K-w68YrBWQhPOlQO-flJztY.QXxITO0wCM2YTMzEzW}

## 11. Challenge

Now, you'll diff two sets of command outputs: `/challenge/print_decoys`, which will print a bunch of decoy flags, and `/challenge/print_decoys_and_flag` which will print those same decoys plus the real flag.

Use process substitution with `diff` to compare the outputs of these two programs and find your flag!

```bash
diff <(/challenge/print_decoys) <(/challenge/print_decoys_and_flag)
```

Output flag:-pwn.college{YwtfZ6PNCHqCeukQjr0m3DyC8S6.0lNwMDOxwCM2YTMzEzW}

## 12. Challenge

Now it's your turn! In this challenge, we have `/challenge/hack`, `/challenge/the`, and `/challenge/planet`. Run the `/challenge/hack` command, and duplicate its output as input to both the `/challenge/the` and the `/challenge/planet` commands! Scroll back through the previous challenges "Duplicating piped data with tee" and "Process substitution for input" if you need a refresher on this method.

```bash
/challenge/hack | tee >(/challenge/the) >(/challenge/planet)
```

Output flag:-pwn.college{8LpyakNYQRGQ46Ntel62DdPL0nS.QXwgDN1wCM2YTMzEzW}


## 13. Challenge

The challenge here, of course, is that the `|` operator links the _stdout_ of the left command with the _stdin_ of the right command. Of course, you've used `2>&1` to redirect stderr into stdout and, thus, pipe stderr over, but this then mixes stderr and stdout. How to keep it unmixed?

In this challenge, you have:

- `/challenge/hack`: this produces data on _stdout_ and _stderr_
- `/challenge/the`: you must redirect `hack`'s _stderr_ to this program
- `/challenge/planet`: you must redirect `hack`'s _stdout_ to this program

```bash
/challenge/hack > >(/challenge/planet) 2> >(/challenge/the)
```

Output flag:-pwn.college{kWrHv2-CiRlEnoCtoQ_CY2CMMAG.QXxQDM2wCM2YTMzEzW}

## 14. Challenge

This challenge will be a simple introduction to FIFOs. You'll need to create a `/tmp/flag_fifo` file and redirect the stdout of `/challenge/run` to it. If you're successful, `/challenge/run` will write the flag into the FIFO! Go do it!

In terminal 1
```bash
mkfifo /tmp/flag_fifo
/challenge/run > /tmp/flag_fifo
```
In terminal 2
```bash
cat /tmp/flag_fifo
```

Output flag:- pwn.college{oIFvNgqCcjG7e5Zuhef7QpWVozd.01MzMDOxwCM2YTMzEzW}
